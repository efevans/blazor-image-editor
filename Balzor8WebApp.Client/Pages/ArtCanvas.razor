@page "/canvas"
@using System.Runtime.InteropServices.JavaScript
@using Balzor8WebApp.Client.Components
@using MudBlazor.Utilities
@using System.Text.Json
@inject IJSRuntime JS
@rendermode InteractiveWebAssembly

<InputFile id="@FileInputId" @ref="InputFileRef" style="display: none;" OnChange="ShowPreview" />
<MudFab HtmlTag="label"
        Color="Color.Primary"
        StartIcon="@Icons.Material.Filled.Image"
        Label="Upload Image"
        Disabled="!AssemblyIsLoaded"
        for="@FileInputId" />
@if (!AssemblyIsLoaded)
{
    <div class="d-flex flex-row justify-center" style="min-height: 25rem;">
        <MudProgressCircular Color="Color.Primary" Indeterminate="true" />
    </div>
}

<div style="@(ImageIsUploaded ? "" : "display: none;")">
    <div class="d-flex flex-row gap-2 my-2">
        <MudButton Color="Color.Secondary" Variant="Variant.Filled" OnClick="HandleReset">Reset</MudButton>
        <MudButton Color="Color.Primary" Variant="Variant.Filled" OnClick="HandleSave">Save</MudButton>
    </div>
    <div class="d-flex flex-row gap-2 my-2">
        <MudButton Color="Color.Primary" Variant="Variant.Filled" OnClick="() => { AddEffect(Effect.FloydDither); }">Floyd-Steinberg Dither</MudButton>
        <MudButton Color="Color.Primary" Variant="Variant.Filled" OnClick="() => { AddEffect(Effect.OrderedDither); }">Ordered Dither</MudButton>
        <MudButton Color="Color.Primary" Variant="Variant.Filled" OnClick="() => { AddEffect(Effect.Invert); }">Invert</MudButton>
        <MudButton Color="Color.Primary" Variant="Variant.Filled" OnClick="() => { AddEffect(Effect.GammaCorrect); }">Gamma Correction</MudButton>
        <MudButton Color="Color.Primary" Variant="Variant.Filled" OnClick="() => { AddEffect(Effect.Pixelate); }">Pixelate</MudButton>
    </div>
    <canvas id="@CleanCanvasId" @ref="CleanCanvasRef" style="display: none;"></canvas>
    <MudStack Row="true" Style="margin-right: -20rem;" Class="flex-grow-1">
        <canvas id="@MainCanvasId" @ref="MainCanvasRef" class="flex-grow-0" style="border: 1px solid black;"></canvas>
        <MudSpacer />
        <MudDropContainer @ref="EffectsUIListRef" ItemIsDisabled="@((item) => !item.Draggable)" T="EffectItem" Items="Effects" ItemsSelector="@((item,dropzone) => true)" ItemDropped="ItemUpdated" Class="d-flex flex-wrap flex-grow-0 align-start" Style="width: 30rem;">
            <ChildContent>
                <MudPaper Class="ml-4 flex-grow-1">
                    <MudList Clickable="true" Class="d-flex flex-column">
                        <MudListSubheader>Effects</MudListSubheader>
                        <MudDropZone T="EffectItem" Identifier="1" Class="flex-grow-1" AllowReorder="true" />
                    </MudList>
                </MudPaper>
            </ChildContent>
            <ItemRenderer>
                <ArtCanvasEffectListItem EffectItem="@context" OnDragStateChangedCallback="OnEffectItemDragStateChanged"></ArtCanvasEffectListItem>
            </ItemRenderer>
        </MudDropContainer>
    </MudStack>
</div>


@code {
    private const string MainCanvasId = "tutorial";
    private const string CleanCanvasId = "clean-canvas";
    private const string FileInputId = "mud-file-uploader";

    private ElementReference MainCanvasRef { get; set; }
    private ElementReference CleanCanvasRef { get; set; }
    private InputFile? InputFileRef { get; set; }

    private bool AssemblyIsLoaded = false;
    private bool ImageIsUploaded = false;

    private MudDropContainer<EffectItem> EffectsUIListRef { get; set; } = null!;

    private void ItemUpdated(MudItemDropInfo<EffectItem> dropItem)
    {
        Effects.ForEach(e => e.Draggable = false);
        Effects.UpdateOrder(dropItem, item => item.Order);
        Effects.Sort((e1, e2) => e1.Order > e2.Order ? 1 : -1);
        ResetImage(MainCanvasId, CleanCanvasId);
        ApplyEffects();
    }

    private void OnEffectItemDragStateChanged()
    {
        EffectsUIListRef.Refresh();
    }

    private List<EffectItem> Effects = new();

    public class EffectItem
    {
        public ICanvasEffect Effect { get; init; } = null!;
        public int Order { get; set; }
        public bool Draggable { get; set; } = false;
    }

    private enum Effect
    {
        FloydDither,
        Invert,
        HalfInvert,
        GammaCorrect,
        Pixelate,
        OrderedDither
    }

    protected override async Task OnInitializedAsync()
    {
        if (OperatingSystem.IsBrowser())
        {
            await JSHost.ImportAsync(this.GetType().Name,
                $"../Pages/{this.GetType().Name}.razor.js");

            Log("I'm logging from interop!");
            AssemblyIsLoaded = true;
        }
    }

    private async Task ShowPreview()
    {
        Log("File Uploaded");
        var dict = new Dictionary<string, string>() { { "a", "b" }, { "c", "d" } };
        var jsonDict = JsonSerializer.Serialize(dict);
        Log2(jsonDict);
        ImageIsUploaded = true;
        Effects.Clear();
        EffectsUIListRef.Refresh();
        await JS.InvokeVoidAsync("previewImage", InputFileRef!.Element, MainCanvasRef, CleanCanvasRef);
    }

    private void HandleSave()
    {
        Log("Save File");
        SaveImage(MainCanvasId);
    }

    private void HandleReset()
    {
        Log("File Reset");
        Effects.Clear();
        ResetImage(MainCanvasId, CleanCanvasId);
        EffectsUIListRef.Refresh();
    }

    private void ApplyEffect(ICanvasEffect effect)
    {
        effect.Apply(MainCanvasId);
    }

    private void ApplyEffects()
    {
        foreach (var effect in Effects)
        {
            ApplyEffect(effect.Effect);
        }
    }

    private void AddEffect(Effect effectType, bool apply = true)
    {
        var effect = (new CanvasEffectBuilder()).Build(effectType);
        Effects.Add(new EffectItem { Effect = effect, Order = Effects.Count });
        EffectsUIListRef.Refresh();

        if (apply)
        {
            ApplyEffect(effect);
        }
    }

    private class GenericCanvasEffect(string name,
                                        Dictionary<string, string> defaultOptions,
                                        Action<string> applyAction) : ICanvasEffect
    {
        public string Name => name;

        public Dictionary<string, string> Options { get; set; } = defaultOptions ?? new Dictionary<string, string>();

        private Action<string> ApplyAction = applyAction;

        public void Apply(string canvasId)
        {
            ApplyAction(canvasId);
        }
    }

    public interface ICanvasEffect
    {
        public string Name { get; }
        public Dictionary<string, string> Options { get; set; }
        void Apply(string canvasId);
    }

    private class CanvasEffectBuilder
    {
        public ICanvasEffect Build(Effect effect) => effect switch
        {
            Effect.FloydDither =>
                new GenericCanvasEffect("Floyd-Steinberg Dither", new Dictionary<string, string>(), ApplyFloydSteinbergDither),
            Effect.OrderedDither =>
                new GenericCanvasEffect("Ordered Dither", new Dictionary<string, string>(), ApplyOrderedDither),
            Effect.Invert =>
                new GenericCanvasEffect("Invert", new Dictionary<string, string>(), ApplyInvert),
            Effect.GammaCorrect =>
                new GenericCanvasEffect("Gamma Correction", new Dictionary<string, string>() { { "slider", "" } }, ApplyGammaCorrection),
            Effect.Pixelate =>
                new GenericCanvasEffect("Pixelate", new Dictionary<string, string>() { { "strength", "" } }, ApplyPixelate),
            _ =>
                new GenericCanvasEffect("Unsupported", new Dictionary<string, string>(), (str) => Log("unsupported effect")),
        };
    }
}